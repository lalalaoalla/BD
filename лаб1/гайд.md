<style>
    yellow{
        color:yellow
    }
</style>

## Код для первого запроса
```
1.	Выбрать поставщиков, поставляющих детали, поставляемые поставщиками, проживающими в Лондоне.
```

детали, которые поставляют поставщики из Лондона
```
select n_det --вывести столбец с номерами деталей
from spj -- из таблицы поставок
join s on s.n_post=spj.n_post --join это типа что нам надо связаться с другой таблицей, типа вывести поставщиков, которые что-то поставляли
where town='Лондон' -- город у поставщиков Лондон
```
Полный запрос:
 ```
 select distinct n_post --вывести столбец без повторений
from spj --из таблицы spj(поставок)
where n_det in (select n_det --где деталь удовл запросу
                     from spj
                     join s on s.n_post=spj.n_post
                     where town='Лондон')


 ```

 ## Код для второго запроса
```
2.	Вывести без повторений пары городов таких, что была поставка детали из первого города для изделия во втором городе. Упорядочить список по алфавиту. 
```

 ```
 SELECT DISTINCT p.town as p, j.town as j --вывод без повторений, столбцов таких, что назвали из как p и j, ипа откуда города
FROM spj -- из таблицы поставок
JOIN p on (p.n_det=spj.n_det)-- где номер детали в таблице поставок совпадает с номером детали в таблице детале1
JOIN j on (j.n_izd=spj.n_izd)-- то же самое, только про изделия
ORDER BY p ASC; --столбец ОТКУДА поставляли по алфавиту
 ```

 ## Код для третьего запроса
 ```
3.	Получить список городов, в которые выполнили поставки ТОЛЬКО поставщики, поставлявшие голубые детали.
 ```
1) Выьерем поставщиков, поставляющих голубые детали

```
SELECT DISTINCT n_post --поставщики без повторений
FROM spj our --из таблицы поставок, our мне для удобства чтобы не путаться
JOIN p ON our.n_det=p.n_det --смотрим где строки, где номер детали из таблицы поставок совпадает с номером детали из таблицы деталей
WHERE cvet='Голубой' --где цвет голубой
```

2) Запрос полностью

```
SELECT town --выводим города
FROM j --из таблица изделий(город ОТКУДА поставляют находится в таблице деталей, а КУДА в таблице изделий)
JOIN spj ON spj.n_izd=j.n_izd --смотрим строки, где номер изделия из таблицы изделий равен номеру изд из таблицы поставок
WHERE n_post IN(SELECT DISTINCT n_post --см пункт1
                 FROM spj our
                 JOIN p ON our.n_det=p.n_det
                 WHERE cvet='Голубой') 
EXCEPT --типа вычитание
SELECT town
FROM j
JOIN spj ON spj.n_izd=j.n_izd
WHERE NOT n_post IN(SELECT DISTINCT n_post --пункт 1, только НЕ поставляют голубые детали
                 FROM spj our
                 JOIN p ON our.n_det=p.n_det
                 WHERE cvet='Голубой')

!!!EXCEPT - что-то наподобие вычитания, то есть первый запрос считывает ВСЕХ поставщиков, ну типа туда поставляют поставщики, кторые делают голубые детали  - ок, НО туда могут поставлять и другие, а нам надо найти города, в которые поставляют ТОЛЬКО голубопоставщики, то есть никто более, первый запрос этого не обеспечивает, поэтому мы вызываем вычитание
Во втором запросе мы берем тех поставщиков, которые НЕ поставляют голубые детали
Ну и, собственно, вычитаем их из общего количества
```

## Код для четвертого запроса
```
4. Вывести полный список городов и для каждого города найти суммарное количество деталей красного цвета, которые были в него поставлены. Города в списке должны быть ВСЕ. Список должен быть упорядочен по алфавиту.
```
Ну тут я уже узнала про практикум
1) Выведем список всех городов упорядоченных по алфавиту в одном списке
```
select town from p --города из p ну и по аналогии
union -- для объединения в 1 список
select town from s 
union 
select town from j 
order by 1 --сортировка
```
2) Вывести количество деталей красного цвета в поставке для каждого города
```
SELECT kol, j.town --кол-во, города, куда поставлялись дет
FROM spj --из таблицы поставок
JOIN p ON spj.n_det=p.n_det -- где ну ты понял крч
JOIN j ON spj.n_izd=j.n_izd --тут тоже
WHERE p.cvet='Красный' --где цвет детали красный
ORDER BY 2 --по городу отсортировали
```
3) Получить суммарное количество поставок в каждый город
```
SELECT sum(kol), j.town --просто получаем теперь сумму кол-в
FROM spj
JOIN p ON spj.n_det=p.n_det
JOIN j ON spj.n_izd=j.n_izd
WHERE p.cvet='Красный'
GROUP BY j.town --группируем по городу
ORDER BY 2 
```
4) Общий запрос:
```
SELECT res.col, town.town --общ кол-во, наши ВСЕ города
FROM (SELECT town FROM p --см пункт 1
      union 
      SELECT town FROM s 
      union 
      SELECT town FROM j) town --обозвали то, что мы получили как town
LEFT JOIN (SELECT sum(kol) col, j.town -- так называемое "левое" соединение, sum(kol) надо было как-то назвать для использования в дальнейшем (col)
           FROM spj --см пункт 3
           JOIN p ON spj.n_det=p.n_det
           JOIN j ON spj.n_izd=j.n_izd
           WHERE p.cvet='Красный'
           GROUP BY j.town 
) res ON res.town=town.town --подводим итоги
ORDER BY 2 сортировка по городам(второй признак в нашем слчае)

!!!LEFT JOIN - Левое внешнее соединение. Всегда содержит как минимум один экземпляр
каждой строки из таблицы, указанной слева от ключевого слова JOIN.
Отсутствующие поля из правой таблицы заполняются значениями NULL.
```

# Модификация информации

## Код для пятого запроса
```
1. Построить таблицу с упорядоченным списком городов, в которых размещается только один поставщик, или производится только одна деталь, или собирается только одно изделие. 
```
1) Города, где живет только один поставщик

```
SELECT town --выбрать столбец городов
FROM s --из таблицы поставщиков
GROUP BY town --группируем по городу
HAVING count(*) = 1

!!! HAVING - ключевое слово, которое используется для фильтрации результатов ПОСЛЕ группировки, в отличие от WHERE, который фильтрует исходные данные *до* группировки
COUNT(*) - функция, которая считает количество строк в каждой группе
=1 - кол-во строк в каждой группе должно быть равно этому числу
```
2) Города, где производится только одна деталь
```
SELECT town -- то же что и пункст выше
FROM p
GROUP BY town
HAVING COUNT(*) = 1
```
3) Города, где изготавливается только одну изделие
```
SELECT town --то же самое
FROM j
GROUP BY town
HAVING COUNT(*) = 1
```
4) В общем окончательный запрос
```
CREATE TABLE town (town character(20));
INSERT INTO town(SELECT town
                FROM s
                GROUP BY town
                HAVING COUNT(*) = 1
                UNION
                SELECT town
                FROM p
                GROUP BY town
                HAVING COUNT(*) = 1
                UNION
                SELECT town
                FROM j
                GROUP BY town
                HAVING COUNT(*) = 1
)
```
## Код для шестого запроса
```
2. Увеличить рейтинг всех поставщиков, имеющих в настоящее время рейтинг меньше, чем у поставщика S5, на величину, равную умноженному на 2 числу выполненных поставщиком поставок.
```

1) Получение рейтинга поставщика S5
```
SELECT reiting
FROM s
WHERE s.n_post = 'S5'
```
2) Получение количества поставок каждого поставщика
```
SELECT s.n_post, COUNT(*) AS count_post -- имя поставщика и его кол-во поставок
FROM spj --из поставок
JOIN s ON s.n_post = spj.n_post --где и тд
GROUP BY s.n_post --группируем по поставщикам

```

3) Общий запрос:
```
UPDATE s SET reiting=reiting + (SELECT COUNT(*)*2 --обновляем таблицу поставщиков, присваиваем новые значения, полученные из запроса, который посчитал кол-во поставок(строк) и умножил кол-во на 2
                                 FROM spj-- см пункт 2
                                 WHERE s.n_post = spj.n_post
                                 GROUP BY s.n_post)
WHERE reiting<(SELECT reiting --см пункт 1
               FROM s
               WHERE s.n_post = 'S5')
```

